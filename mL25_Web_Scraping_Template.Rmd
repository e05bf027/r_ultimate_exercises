---
title: 'Web Scraping'
author: "David Hannon"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
suppressPackageStartupMessages(library(knitr))
```

# Introduction

Web scraping is used to extract data from websites. This is easy with R. In this tutorial you will learn how to extract a table from a complex site. In the Wikipedia article (Wind power by country)[https://en.wikipedia.org/wiki/Wind_power_by_country] you find a table with installed wind power capacity embedded in a complex site with text, graphs, and other tables. How can you extract information from this specific table? 

* Objective: Learn how to extract components of websites
* Requirements: Google Chrome, R Basics

# Preparation

First, you need to install and load the package _rvest_.

```{r get_package, echo=TRUE}
library(rvest)
library(tidyverse)
```

Now you can define the url.
```{r url, echo=TRUE}
url <- "https://en.wikipedia.org/wiki/Wind_power_by_country"
```

To get the information of the specific table you need to get _xpath_ information. _xpath_ can be used to navigate in XML documents. We will use it to identify the table of interest. If you have installed Google Chrome it is easy. If you are using a different browser, there are many addins for this purpose. XML stands for **Ex**tensible **M**arkup **L**anguage.

XML tags identify the data and are used to store and organize the data, rather than specifying how to display it like HTML tags, which are used to display the data.

If you in the browser and on the website, just click CTRL + SHIFT + I or right-click and Inspect. On the right side of your screen a new windows appears called DevTools. If you hover over the items the objects on the website are highlighted. Now you browse until you find the table highlighted. 

In Firefox go to Tools > Browser Tools > Web Developer Tools.

Now you only have to copy the xpath string by _right-clicking_ --> _Copy_ --> _Copy XPath_. This is used within R for accessing the table. This reference can be used in html_node(). At first the complete

```{r download}
# download.file() is in utils rather than rvest#
download.file(url = url, destfile = 'windTable.html', quiet = T)
windTable <- read_html('windTable.html')
```

In a first step the complete url is downloaded. In a second step only the relevant component, identified by xpath, is filtered. Finally, this needs to be converted from HTML to a dataframe. For this _html_table()_ is applied.

```{r xpath}

# xpath produces a different character string if you isolate it from Chrome vs Firefox. I find the Firefox one to be more readable.
xpath <- '/html/body/div[3]/div[3]/div[5]/div[1]/table[2]'
windTable <-  windTable %>% 
  html_node(xpath = xpath) %>% 
  html_table(fill = T)
```

Now, a dataframe _windTable_ is available for further processing.

An important point here. Golnick advocates an approach where a for loop is used with `gsub` to replace commas, hyphens, etc. The problem here seems to be a problem when _gsub_ or _str_replace_all_ is used on the dataframe produced by `rvest`. It produces a tibble, and every time I try to run Golnick's loop I get a very strange output of unusual concatenated characters. My solution is to alter the tibble to a dataframe using the base R function `as.data.frame`. It seems the difference here MIGHT be that when you isolate a column from this format, it becomes a vector rather than smaller tibble. I think.

```{r table_prep, echo=TRUE}
# GOLNICK/R ULTIMATE SOLUTION
# ===========================
# for (i in 2:ncol(windTable)) {
	# windTable[, i] <- gsub(",", "", windTable[, i])
	# windTable[, i] <- gsub("-", 0, windTable[, i])
	# windTable[, i] <- as.numeric(as.character(windTable[, i]))
# }

windTable <- as.data.frame(windTable)
for (i in 3:ncol(windTable)) {
  windTable[, i] <- str_replace_all(windTable[, i], pattern = ',', replacement = '')
  windTable[, i] <- str_replace_all(windTable[, i], pattern = '-', replacement = '')
  windTable[, i] <- as.numeric(as.character(windTable[, i]))
}
windTable <- as_tibble(windTable)
# the above solution switches windTable from tibble to dataframe, runs a tidyverse loop, and then changes it back to tibble.
```

# Result

Finally, let's take a look at the table and compare it to the source. It worked perfectly.

```{r table}
windTable %>% 
  select(1:5) %>% 
  head()
```