---
title: "Outlier Detection"
author: "David Hannon"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(knitr)
```


# Introduction

We will work on iris the dataset. We load it with data().

```{r}
data(iris)
iris_tib <- as_tibble(iris)
```

We want to detect outliers for one specific variable (here: “Petal.Length”). Let’s visualise the data with ggplot(). 

The graph shows a boxplot for each grouping (here: “Species”). A boxplot is a helpful visualisation for univariate distributions. If you need some refreshment on how to read it, you find a link at the end of this article.

```{r}
g <- iris %>% ggplot(data = ., aes(x = Species, y = Petal.Length)) +
  geom_boxplot() +
  labs(title = 'Boxplot of Iris Dataset',
       xlab = 'Species',
       ylab = 'Petal length (cm)')

g
```

The dots represent outliers.

- Outliers are defined (in this case) as values that are 3 times IQR **above** third quantile or 3 times IQR **below** first quantile. This is best practice rather than hard mathematical conclusion.
- **Suspected** outliers are 1.5 times IQR above third quantile or 1.5 times IQR below first quantile.

In other sources you will find the nomenclature 'mild' (1.5 IQR) and 'extreme' (3 IQR) outliers.

# Z-Score Outlier Calculation

The calculation is straightforward. For each species-

1. We calculate first quantile (Q1) and third quantile (Q3).

2. With this we can calculate IQR (= Q3 – Q1).

3. Now we calculate upper and lower limits according to shown definition.

```{r}
iris_outliers <- iris_tib %>% 
  group_by(Species) %>% 
  summarise(quartile_1 = quantile(Petal.Length, probs = 0.25),
            quartile_3 = quantile(Petal.Length, probs = 0.75),
            IQR = quartile_3 - quartile_1,
            upper_inner_limit = quartile_3 + (IQR * 1.5),
            lower_inner_limit = quartile_1 - (IQR * 1.5))

tbl_df(iris_outliers)

# important note: I originally rewrote Golnick's code with
# quartile_1 = quantile(data = .$Petal.Length, probs = 0.25) BUT it produces a 
# result I wasn't expecting. I think '.$' told it to use the ENTIRE column for
# the calculation rather than the grouped variable
```

This information now is applied to our dataset. We will first join it with “iris”, before we perform some simple comparisons to find outliers.

For the joining we use left_join() from dplyr package. We a nicer view we remove variables that are not needed any more with select(), and take a look at the head of this dataset.

```{r}
iris_tib <- iris_tib %>% 
  left_join(x = iris_tib,
            y = iris_outliers,
            by = "Species")

iris_tib <- iris_tib %>%
  select(-quartile_1, -quartile_3, -IQR)
```

```{r}
# this requires us to create a logical field, where we can designate 

iris_tib <- iris_tib %>% 
  mutate(is_outlier = if_else(condition = Petal.Length > upper_inner_limit | Petal.Length < lower_inner_limit, true = "Outlier", false = "Not outlier"))
```

Outliers are studied.

```{r}
iris_tib %>% 
  filter(is_outlier == "Outlier") %>% 
  kable()
```

You see there are four outliers for species setosa, and one outlier for versicolor. This are the same points that we have seen in our ggplot boxplot.

It is up to you to perform the calculation for extreme outliers (3 times IQR).

# Dbscan Outlier Detection

```{r}
# install.packages("dbscan")
library(dbscan)
```

Two parameters need to be specified: epsilon and min_points

## Optimal value for epsilon

Average of distances of each point to its k nearest neighbors is calculated. k (corresponds to min_points) and is specified by user.

It is aimed to determine the knee - which represents optimal epsilon parameter.

```{r}
# code here
```
 
 For epsilon 0.4 seems to be a reasonable choice.
 
 Now dbscan can be started.
 
```{r}
# code here
```

## Clusters
 
```{r}
# code here
```
 
We see there are four clusters recognized.

## Outliers Plotting

In total there are 32 outliers.
 
```{r}
# code here
```
 
```{r}
# code here
```
 
```{r}
iris_mod <- iris %>% 
  gather(key = "variable", value = "value", 1:4)
g <- ggplot (iris_mod, aes(x=Species, y = value, col = cluster))
g <- g + facet_grid(. ~ variable)
g <- g + geom_jitter()
g
```


 