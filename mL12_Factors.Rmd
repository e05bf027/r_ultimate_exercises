---
title: "Factors"
author: "David Hannon (modification of Bert Gollnick)"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = T, message = T)
```

# Introduction

A factor is very similar to a vector. The difference is that only a fixed list of values (so called levels) is allowed.

# Creation

Factors store categorical values.

```{r}
x <- factor(c("a", "b", "c", "b"))
levels(x)
```

# Changing Values and Levels

You can reassign values.

```{r}
x[1] <- "c"
```

But you cannot use values that are not defined in the levels.

```{r}
x[1] <- "d"
x
```

You can't combine factors

```{r}
factor1 <- factor("first")
factor2 <- factor("second")
c(factor1, factor2)
```

When should you use it? --> When you know the allowed range of values:

```{r}
worktype_char <- c("employed", "unemployed", "employed")
# if you want to keep status "retired" as well, you need to add it as a level, even if your initial data does not have it.
worktype_factor <- factor(x = worktype_char, 
                          levels = c("employed", "unemployed", "retired"))
```

This way you can get information on that level as well:

```{r}
table(worktype_factor)
```

# Data Import Problem

When you import data and the column has some non-numeric values, the column type will be set to factor. One reason might be a wrong decimal separator.

```{r}
txt_data <- read.table("./data/factorImport.txt", 
                       header = T)
txt_data
```

# Casting Factors to Numeric

If you want to cast it to numeric, you need to cast it to character at first!

Otherwise you get the factor levels instead of the values.

```{r}
# how NOT to do it
levels(txt_data$value)
as.numeric(txt_data$value) 
```

```{r}
# how to do it
as.numeric(as.character(txt_data$value))
```

Interestingly this doesn't work as Golnick says! There are various ways to fix
this, but one option is the `readr` package. In order to do it, we use the 
function _parse_number_. Within this there is a way to set the 'locale'. It is 
here that we tell R that a comma will be used as a decimal point. 

```{r}
library(readr)
parse_number(as.character(txt_data$value), locale = readr::locale(decimal_mark = ","))
```

The above says to R: take the `value` col from `txt-data` and coerce it to 
characters. To this input, apply settings that in this locale a comma is used
as a decimal mark.

Another way to do it is using `grep` (a base function). This can be used for
pattern matching and replacement. The exact function **within** this is the
`sub` function.

```{r}
txt_wrangled <-  sub(pattern = ',', replacement = '.', x = txt_data$value) %>% 
  as.numeric()
```

The issue with this is numbers such as 1.234,56 in whicvh case that first
method is the better way.